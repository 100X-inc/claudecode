---
tags:
  - プログラミング
  - テクノロジー
  - SOLID原則
created: 2026-01-18
---

# プリンシパルオブプログラミング - ナレッジマップ

## メタ情報
- **著者**: 上田勲
- **原典/ベース**: ソフトウェア開発の歴史的プリンシプル集
- **ジャンル**: プログラミング原則・設計思想
- **キーワード**: プリンシプル、設計原則、ソフトウェアアーキテクチャ、KISS、DRY、YAGNI、UNIX哲学

---

## コアコンセプト一覧

| カテゴリ | 主要プリンシプル | 概要 |
|---------|----------------|------|
| 前提 | 銀の弾丸はない、コードは設計書、コードは変更される | プログラミングの普遍的事実 |
| 原則 | KISS、DRY、YAGNI、PIE、SLAP、OCP、名前重要 | プログラミングの基本原則 |
| 思想 | プログラミングセオリー、アーキテクチャ根底技法、UNIX思想/哲学 | 設計思想・価値観 |
| 視点 | 凝集度、結合度、直交性、可逆性、コードの臭い、技術的負債 | 評価視点・見方 |
| 習慣 | プログラマの3大美徳、ボーイスカウトの規則、エゴレスプログラミング | 行動指針 |
| 手法 | 曳光弾、契約による設計、防御的プログラミング、ラバーダッキング | 具体的技法 |
| 法則 | ブルックスの法則、コンウェイの法則、割れた窓の法則、エントロピーの法則 | アンチパターン |

---

## フレームワーク詳細

### 第1章: 前提 〜プログラミングの変わらぬ真実〜

#### プログラミングに銀の弾丸はない (No Silver Bullet)

**定義**:
プログラミングの諸問題を鎮める万能の解決策・特効薬は存在しない。

**ソフトウェアの本質的困難性 (4つの性質)**:
1. **複雑性**: 数千万行規模、非線形に増大する依存関係
2. **同調性**: 実世界に同調し続ける必要性
3. **可変性**: 変化し続けなければならない宿命
4. **不可視性**: 概念の集積で目に見えない

**適用方法**:
- 歴史を学び「複雑さ」と地道に戦う
- 偶有部分(ビルド環境、言語、ライブラリ等)の改善
- 自動化による作業効率向上

#### コードは設計書である (Code as Design)

**定義**:
上流工程の「基本設計」から「テスト」「デバッグ」まですべてが「設計」であり、そのアウトプットが設計書である「コード」。製造はコンパイラやビルドシステムが行う。

**構成要素**:
1. **プログラミングは設計行為**: 創造的で技芸を必要とする作業
2. **設計作業は不可分**: 基本設計からデバッグまで分担すべきでない
3. **早期コーディング**: コードを早く書き始めないと設計が終わらない

**ロゼッタストーン**:
将来の保守担当者への簡潔な手引書
- ビルドとテストのプロセス実行方法
- アーキテクチャ全体像の図
- 設計理由(Why)の記述

#### コードは必ず変更される (Code Will Be Changed)

**定義**:
コードは一度書いて終わりではなく、必ず変更される。変更されることを最大優先度で考慮すべき。

**変更が発生する理由**:
- 障害修正
- ユーザー要望による機能拡張
- ビジネス環境の変化
- 新規開発中のリファクタリング

**適用方法**:
- 変更に強いコードを書く
- コードの読みやすさを最優先
- 書く時間より読む時間が長いことを認識

---

### 第2章: 原則 〜プログラミングのガイドライン〜

#### KISS (Keep It Simple, Stupid / Keep It Short and Simple)

**定義**:
コードをシンプルに保つことを最優先の価値とする。複雑にならないよう意識し続ける。

**Why (なぜ必要か)**:
- コードは自然に任せると無秩序・複雑になる
- 複雑なコードは読みにくく、修正しにくく、品質が悪化
- シンプルなコードは読みやすく、理解しやすく、修正容易

**How (どうすれば)**:
1. 常に「もっともシンプルなものは何か」と問いかける
2. 新しく覚えた技術を使いたいだけで使わない
3. 将来の必要に備えて過剰なコードを書かない
4. 勝手に要件を加えない

**関連コンセプト**:
- **less is more**: より少ないことは、より豊かなこと
- **オッカムの剃刀**: 同じ説明なら最も単純なものが正しい

#### DRY (Don't Repeat Yourself)

**定義**:
同じコードを重複して書かない。コードの重複を避け、発見したら速やかに排除する。

**重複の種類**:
1. ロジックのコピー＆ペースト
2. 同じ条件を扱う制御文の重複
3. 定数リテラルの直接埋め込み
4. コードをそのまま説明するコメント

**Why (なぜ必要か)**:
重複があると以下の困難が発生:
1. コードを読む作業が難しくなる(量的・質的に複雑)
2. コードを修正する作業が難しくなる(修正漏れリスク、整合性)
3. テストがない(レガシーコード)

**How (どうすれば)**:
- コードを抽象化する
  - 処理のまとまりを「関数化」「モジュール化」
  - データを「定数化」
- 作業の重複を「自動化」(継続的インテグレーション)

**関連コンセプト**:
- **WET** (Write Every Time/Write Everything Twice): DRYの対義語(皮肉的表現)
- **OAOO** (Once and Only Once): DRYと同義、プログラミング文脈に限定
- **OFOP** (One Fact in One Place): データベースにおけるDRY

#### YAGNI (You Aren't Going to Need It)

**定義**:
「たぶん必要になるだろう」で書かず、本当に必要になった時、必要なものだけを書く。

**Why (なぜ必要か)**:
- 拡張性を考慮したコードは予想がほとんど外れる
- 予想が外れると時間が無駄
- 使われていないコードが複雑性を増す
- 理由不明の無用の長物が邪魔者になる

**How (どうすれば)**:
- 汎用性より単純性を考える
- 「使えること」に価値を置く
- 単純なコードの方が変更が簡単

**関連コンセプト**:
- **DTSTTCPW** (Do The Simplest Thing That Could Possibly Work): もっともシンプルな方法で行え

#### PIE (Program Intently and Expressively)

**定義**:
意図を明確に表現してプログラミングする。コードは「人」が読むためのもの。

**Why (なぜ必要か)**:
- コードだけがソフトウェアの動作を「正確に」「完全に」知る手がかり
- 要件定義書、設計書は正確性・完全性がない
- コードは書く時間より読む時間がはるかに長い

**How (どうすれば)**:
- 「読みやすさ」を「書きやすさ」より重視
- 「読む効率」を「実行の効率」より優先
- 小賢しい書き方で頭脳アピールしない
- コメントで「Why」(なぜそれをしているか)を表現

**関連コンセプト**:
- **文芸的プログラミング** (Literate Programming): コードをドキュメンテーションにする究極形
- **モグラたたき開発を避ける**: 品質を犠牲にして短期スピード重視は長期的損失

#### SLAP (Single Level of Abstraction Principle)

**定義**:
抽象化レベルを統一する。高水準と低水準を分離し、各層で抽象レベルを揃える。

**構成要素**:
1. 関数を抽象レベルに沿って分割
2. 同じ関数内のコードの抽象レベルをすべて統一
3. 優れた書籍のような構成(目次と本文)

**Why (なぜ必要か)**:
- 「要約性」と「閲覧性」を同時に満たす
- 抽象度が急に変わるとコードの流れが途切れる
- 理解の飛びが発生し、読む人の邪魔になる

**How (どうすれば)**:
- 関数を構造化する
- **複合関数** (Composed Method): 1段低いレベルの関数を呼び出す構成
- 複合関数は極力小さく(1行でも関数化)
- 様々な抽象レベルの関数を同じ関数内で呼ばない

**コードと書籍のアナロジー**:
- 序文 → ファイル先頭のコメント
- 目次 → 関数の一覧
- セクション → 防波堤コメント
- 章 → 関数
- 段落 → コード内ブロック(空白行で区切り)
- 文 → ステートメント

#### OCP (Open-Closed Principle)

**定義**:
オープン・クローズドの原則。「拡張に対して開いている」「修正に対して閉じている」を同時に満たす設計。

**構成要素**:
1. **拡張に対して開いている**: コードの振る舞いを拡張できる
2. **修正に対して閉じている**: 拡張しても他のコードはまったく影響を受けない

**Why (なぜ必要か)**:
- ソフトウェアは生き続ける限り変化する
- 寿命は想定より長くなる傾向
- 「硬い」設計は少しの変更でも依存関係を持つすべての箇所に影響

**How (どうすれば)**:
- インタフェースを使って設計
- クライアントとサーバーの間に「クライアントインタフェース」を設ける
- **流動的要素のカプセル化**: 変化がありそうな部分をインタフェースの裏に隠す

**適用範囲の注意**:
- どこにでも適用するのはやり過ぎ(無駄で冗長)
- 1度目の変更を受けてから対策を施す戦略
- 変更内容の完全予測より、変化しそうな部分を予測

**実装技術**:
- オブジェクト指向の「ポリモーフィズム」
- デザインパターン: Strategy、Observer、Template Method、Decorator
- **バリエーション防護壁** (Protected Variations)

#### 名前重要 (Naming Is Important)

**定義**:
プログラミングにおいて「命名」を最重要課題として認識し、慎重に取り組む。

**Why (なぜ重要か)**:
1. **名前を付ける行為**: 適切な名前を付けられる = 正しく理解・設計されている
2. **名前そのもの**: プログラマ同士のコミュニケーション最大の場

**名前はコードを読む人への「UI」**:
- 適切な名前: 責務を通知し、詳細を隠蔽
- 不適切な名前: 内部解析を強いる、脳への過負荷

**How (どうすれば)**:
1. より多くの情報を詰め込む(「短いコメント」と考える)
2. 誤解されないよう注意
3. 「効果」と「目的」を説明、「手段」に言及しない
4. テストを先に書いて使用者視点で考える
5. 発音可能なものにする
6. 検索可能なものにする

**関連コンセプト**:
- **メンタルマッピング回避**: 規約・問題領域から外れた用語を使わない
- **ループバックチェック**: 説明→名前→説明の順で一致するか確認(名前可逆性)

---

### 第3章: 思想 〜プログラミングのイデオロギー〜

#### プログラミングセオリー (Theory of Programming)

**定義**:
最高のコード(拡張方法が多く、余分な要素がなく、読みやすく理解しやすい)を実現するための価値観と原則の体系。

**3つの価値**:
1. **コミュニケーション**: プログラマ間でコードを通じた意思疎通
2. **シンプル**: 複雑性の排除
3. **柔軟性**: 変更への対応力

**6つの原則**:
1. **結果の局所化**: 変更の影響を局所に閉じ込める
2. **繰り返しの最小化**: DRYの徹底
3. **ロジックとデータの一体化**: 関連するものを近くに配置
4. **対称性**: 似た問題には似た解決策
5. **宣言型の表現**: 「何を」を表現、「どのように」を隠蔽
6. **変更頻度**: 変更頻度の異なるものを分離

#### アーキテクチャ根底技法

ソフトウェアアーキテクチャを構成する10の基本技法:
1. **抽象**: 本質的な特性のみを抽出
2. **カプセル化**: 内部の詳細を隠蔽
3. **情報隠蔽**: 変更されやすい設計決定を隠す
4. **パッケージ化**: 関連要素をグループ化
5. **関心の分離**: 異なる関心事を分離
6. **充足性、完全性、プリミティブ性**: 必要十分な機能提供
7. **ポリシーと実装の分離**: 方針と実装詳細を分離
8. **インタフェースと実装の分離**: 契約と実装を分離
9. **参照の一点性**: 情報を一箇所に集約
10. **分割統治**: 問題を分割して解決

#### UNIX思想 (17の原則)

UNIXで育まれた優れたプログラミングのための原則:

1. **モジュール化の原則**: シンプルな部品、明確なインタフェース
2. **明確性の原則**: 巧妙さより明確さ
3. **組み立て部品の原則**: プログラムをフィルタとして設計
4. **分離の原則**: メカニズムとポリシーを分離
5. **単純性の原則**: シンプルな設計
6. **倹約の原則**: 大きなプログラムは最後の手段
7. **透明性の原則**: ソフトウェアの動作を目視可能に
8. **安定性の原則**: 安定性は透明性と簡潔性に依存
9. **表現性の原則**: データは知識、ロジックではなくデータに
10. **驚き最小の原則**: インタフェースは驚きを最小限に
11. **沈黙の原則**: 言うべきことがなければ黙る
12. **修復の原則**: 早めに失敗させて騒ぎ立てる
13. **経済性の原則**: プログラマの時間を節約
14. **生成の原則**: コードを書くコードを書く
15. **最適化の原則**: 最適化前にプロトタイプ
16. **多様性の原則**: 不信感の原則
17. **拡張性の原則**: 将来の成長のための設計

#### UNIX哲学 (9の定理)

UNIXの設計哲学:

1. **小は美なり**: 小さく、軽く、シンプル
2. **1つ1仕事**: 1つのことをうまくやる
3. **即行プロトタイプ**: すぐにプロトタイプを作る
4. **効率性より移植性**: 移植性を犠牲にしない
5. **データはテキスト**: フラットテキストファイルにデータを格納
6. **レバレッジ・ソフトウェア**: ソフトウェアの梃子を活用
7. **シェルスクリプト活用**: 梃子と移植性を高める
8. **対話インタフェース回避**: 捕囚のインタフェースを避ける
9. **フィルタ化**: すべてのプログラムをフィルタに

---

### 第4章: 視点 〜プログラマの観る角度〜

#### 凝集度 (Cohesion)

**定義**:
モジュールに含まれる機能の純粋さを表す尺度。モジュール内の要素同士がどれだけ密接に関係しているか。

**7つの強度レベル**(高い順):
1. **機能的凝集**: 単一の明確な機能
2. **情報的凝集**: 同じデータ構造を操作
3. **連絡的凝集**: 同じデータを使い連続実行
4. **手順的凝集**: 特定の手順で実行
5. **時間的凝集**: 特定時期に実行
6. **論理的凝集**: 論理的に似た複数機能
7. **暗号的凝集**: 無関係な要素の寄せ集め

**適用方法**:
- 凝集度の高いモジュール(機能的凝集)を目指す
- 関係性の強い要素のみを含める
- 適度に細分化する

#### 結合度 (Coupling)

**定義**:
モジュール同士の関係の密接さを表す尺度。結合が強いほど独立性が低く、変更の影響が大きい。

**6つのレベル**(良い順):
1. **データ結合**: 必要最小限のデータのみ受け渡し
2. **スタンプ結合**: データ構造全体を受け渡し
3. **制御結合**: 制御情報(フラグ等)を受け渡し
4. **外部結合**: 外部の共通データを参照
5. **共通結合**: 共通領域を複数モジュールで参照
6. **内容結合**: 他モジュールの内部を直接参照・変更

**適用方法**:
- データ結合を目指す
- 必要最小限のデータのみ受け渡す
- 共通データ領域の使用を避ける

#### 直交性 (Orthogonality)

**定義**:
システムのコンポーネント同士が独立していること。あるコンポーネントの変更が他のコンポーネントに影響を与えない。

**メリット**:
1. **生産性の向上**: 変更が局所化、テストが容易
2. **リスクの削減**: 影響範囲が限定、再利用性向上

**適用方法**:
- 責任の明確化
- モジュール間の依存を最小化
- グローバルデータの回避

#### 可逆性 (Reversibility)

**定義**:
重要な決定を簡単に覆せるようにする。変更コストを最小化する設計。

**適用方法**:
- 特定の技術・ベンダーへの依存を最小化
- アーキテクチャの柔軟性確保
- 抽象化層の導入

#### コードの臭い (Code Smell)

**定義**:
コードに潜む問題の兆候。リファクタリングが必要なサイン。

**代表的な臭い**:
- 重複したコード
- 長いメソッド
- 巨大なクラス
- 長いパラメータリスト
- 変更の分散
- データの群れ
- 基本データ型への執着

#### 技術的負債 (Technical Debt)

**定義**:
「修正しにくい」「理解しにくい」といったコードの問題部分を「借金」に喩えた概念。

**悪循環**:
短期的な近道 → コード品質低下 → 修正コスト増大 → さらなる近道 → 破綻

**対処法**:
- 負債を可視化
- 計画的な返済
- 新規負債の抑制

---

### 第5章: 習慣 〜プログラマのルーティーン〜

#### プログラマの3大美徳

**定義**:
優れたプログラマが持つべき3つの美徳:
1. **怠惰** (Laziness): 手間を省くため努力する
2. **短気** (Impatience): 待たされることを嫌う
3. **傲慢** (Hubris): 誇りを持って完璧を目指す

#### ボーイスカウトの規則

**定義**:
「自分のいた場所は、そこを去る時には来た時よりも美しくする」

**適用方法**:
- コードに触れるたびに少しでも改善
- 小さなリファクタリングの積み重ね
- レガシーコードの段階的改善

#### エゴレスプログラミング (10の戒め)

**定義**:
自我を捨てたプログラミング。コードへの個人的執着を排除。

**10の戒め**:
1. あなたはコードではない
2. レビューの目的は改善
3. 完璧な結論は存在しない
4. 専門性よりチーム全体の最適化
5. 批判の仕方に注意
6. 地位や権威ではなく知識で争う
7. 代替案を持つ
8. 議論ではなく問題解決
9. 全員が学ぶ
10. 反対意見も尊重

---

### 第6章: 手法 〜プログラマの道具箱〜

#### 曳光弾 (Tracer Bullet)

**定義**:
システムの全体像を早期に可視化するため、エンド・ツー・エンドで動く最小限の実装を行う手法。

**メリット**:
- 即時フィードバック
- 実環境での検証
- 統合プラットフォームの早期構築
- デモ可能なプロダクト

**プロトタイプとの違い**:
- 曳光弾: 最終システムの骨格、本番コード
- プロトタイプ: 使い捨て、学習目的

#### 契約による設計 (Design by Contract)

**定義**:
関数やモジュールの責任を明確化するため、事前条件・事後条件・不変条件を定義する手法。

**構成要素**:
1. **事前条件** (Precondition): 呼び出し側の責任
2. **事後条件** (Postcondition): 実装側の責任
3. **不変条件** (Invariant): 常に満たすべき条件

#### 防御的プログラミング

**定義**:
想定外の状況に備え、エラー処理を徹底する手法。

**適用方法**:
- 入力値の検証
- エラーハンドリングの徹底
- 異常系の明示的処理
- アサーションの活用

#### ラバーダッキング (Rubber Ducking)

**定義**:
問題を誰か(ゴム製のアヒル等)に説明することで、自分で解決策を見つける手法。

**メリット**:
- 問題の整理
- 前提の再確認
- 新しい視点の獲得

---

### 第7章: 法則 〜プログラミングのアンチパターン〜

#### ブルックスの法則

**定義**:
「遅れているソフトウェアプロジェクトへの要員追加は、プロジェクトをさらに遅らせる」

**理由**:
- 立ち上げコストの発生
- コミュニケーションコストの増大(n(n-1)/2)
- タスクの分割可能性の限界

#### コンウェイの法則

**定義**:
「システムを設計する組織は、その組織のコミュニケーション構造をそっくりまねた構造の設計を生み出す」

**適用**:
- 組織構造とアーキテクチャの整合性を意識
- 逆コンウェイ戦略: 望ましいアーキテクチャに合わせて組織を構成

#### 割れた窓の法則

**定義**:
「割れた窓を放置すると、建物全体が荒廃する」。小さな問題の放置が全体の品質低下を招く。

**適用方法**:
- 小さな問題を即座に修正
- コードの臭いを放置しない
- リファクタリングの習慣化

#### エントロピーの法則

**定義**:
ソフトウェアは自然に無秩序(高エントロピー)へと向かう。

**対処法**:
- 継続的なリファクタリング
- コードレビュー
- 自動テストによる品質維持

#### 80-10-10の法則

**定義**:
機能の80%は10%のコードで実現でき、残り20%の機能に90%のコストがかかる。

**適用**:
- コア機能への集中
- 過剰な完璧主義の回避
- MVPアプローチ

#### セカンドシステム症候群

**定義**:
最初のシステムの成功後、2番目のシステムで過剰設計に陥る現象。

**原因**:
- 最初のシステムで実現できなかった機能を詰め込む
- 成功体験による過信

**対処法**:
- YAGNIの徹底
- シンプルさの維持

#### 車輪の再発明

**定義**:
既存のソリューションがあるにも関わらず、ゼロから作り直すこと。

**対処法**:
- 既存ライブラリ・フレームワークの活用
- ただし、学習目的や特殊要件がある場合は正当化される

#### ヤクの毛刈り (Yak Shaving)

**定義**:
本来の目的から逸れて、関連する別の作業に延々と取り組んでしまうこと。

**対処法**:
- 本来の目的を常に意識
- 作業の優先順位付け
- タイムボックスの設定

---

## 成功事例

(この書籍は原則・思想を体系化したものであり、個別の成功事例の記載は少ない。各プリンシプルは歴史的に検証された知見の集約)

---

## 引用・参考

### 主要参考文献

- **人月の神話** (Frederick P. Brooks): 銀の弾丸、ソフトウェアの本質的困難性
- **達人プログラマー** (Andrew Hunt, David Thomas): DRY、可逆性、曳光弾
- **アジャイルソフトウェア開発の奥義** (Robert C. Martin): OCP、設計原則
- **Clean Code** (Robert C. Martin): 命名、関数設計
- **リーダブルコード** (Dustin Boswell): 読みやすいコード
- **The Art of UNIX Programming** (Eric S. Raymond): UNIX思想・哲学
- **Code Complete** (Steve McConnell): ソフトウェア構築全般
- **レガシーコード改善ガイド** (Michael Feathers): 技術的負債、テスト
- **XPエクストリーム・プログラミング入門** (Kent Beck): アジャイル実践

### 全97プリンシプル構成

**第1章 前提**: 3プリンシプル
**第2章 原則**: 7プリンシプル
**第3章 思想**: 55プリンシプル(プログラミングセオリー10、アーキテクチャ根底技法10、アーキテクチャ非機能要件6、7つの設計原理7、UNIX思想17、UNIX哲学9+小定理)
**第4章 視点**: 6プリンシプル
**第5章 習慣**: 6プリンシプル
**第6章 手法**: 6プリンシプル
**第7章 法則**: 9プリンシプル

---

## まとめ

本書は、ソフトウェア開発の歴史の中で生き残った普遍的・本質的な知識(プリンシプル)を97個体系化した、プログラマ成長のための指針集。「What(どういうことか)」「Why(なぜ必要か)」「How(どうすれば良いか)」の3軸で各プリンシプルを解説。

**コアメッセージ**:
- プログラミングに銀の弾丸はない
- コードはシンプルに保ち、重複を排除し、必要最小限に
- コードは人が読むために書く
- 変更されることを前提に設計する
- プリンシプルは技術の土台となり、習得を加速させる

---

## 関連ドキュメント

### 関連分野
- [[AIドリブン経営]] - 技術活用の経営戦略
- [[コトラーのマーケティング5.0]] - テクノロジーとビジネスの融合
